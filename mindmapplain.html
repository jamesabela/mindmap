<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title id="document-title">Mind Map</title>
  <script src="https://cdn.jsdelivr.net/gh/gitbrent/pptxgenjs@3.12.0/libs/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/gh/gitbrent/pptxgenjs@3.12.0/dist/pptxgen.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

  <!-- Google Fonts: Inter -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#4a90e2">
  <link rel="apple-touch-icon" href="icon.svg">

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then(reg => console.log('Service Worker registered'))
          .catch(err => console.log('Service Worker registration failed: ', err));
      });
    }
  </script>

  <style>
    :root {
      --font-family: 'Inter', sans-serif;
      --bg-gradient: #ffffff;
      --glass-bg: rgba(255, 255, 255, 0.9);
      --glass-border: rgba(0, 0, 0, 0.1);
      --glass-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      --node-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
      --node-hover-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
      --primary-color: #4a90e2;
      --text-color: #333;
      --toolbar-bg: rgba(255, 255, 255, 0.95);
    }

    body {
      font-family: var(--font-family);
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: var(--bg-gradient);
      color: var(--text-color);
    }

    #mindmap-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      cursor: grab;
      /* Default cursor indicates panning available */
    }

    #mindmap-container:active {
      cursor: grabbing;
    }

    #canvas-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      transform-origin: 0 0;
      pointer-events: none;
      /* Helper to let clicks pass through to background for panning if needed, but nodes need events */
    }

    /* We need pointer events on the layer's children, but the layer itself shouldn't block */
    #canvas-layer>* {
      pointer-events: auto;
    }

    .node {
      position: absolute;
      padding: 12px 20px;
      background: var(--glass-bg);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      cursor: pointer;
      user-select: none;
      transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 500;
      box-shadow: var(--node-shadow);
      white-space: nowrap;
      min-width: 120px;
      min-height: 50px;
      box-sizing: border-box;
      color: #333;
    }

    .node:hover {
      transform: translateY(-2px);
      box-shadow: var(--node-hover-shadow);
      background: rgba(255, 255, 255, 0.85);
    }

    .node:focus {
      outline: none;
      box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.3), var(--node-hover-shadow);
    }

    .central-node {
      font-size: 24px;
      font-weight: 700;
      background: rgba(255, 255, 255, 0.9);
      border: 2px solid rgba(255, 255, 255, 0.8);
      padding: 20px 30px;
      min-width: 160px;
      min-height: 80px;
    }

    svg {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
      pointer-events: none;
      width: 100%;
      height: 100%;
      overflow: visible;
    }

    /* SVG Line Styling */
    line {
      stroke: rgba(0, 0, 0, 0.4);
      stroke-width: 2px;
      transition: stroke 0.3s;
    }

    /* Toolbar Styling */
    #toolbar-dock {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: row;
      gap: 4px;
      z-index: 100;
      align-items: center;
      width: auto;
      max-width: 98%;
      flex-wrap: nowrap;
      justify-content: center;
      pointer-events: none;
      background: var(--toolbar-bg);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      padding: 4px 8px;
      border-radius: 8px;
      box-shadow: var(--glass-shadow);
      border: 1px solid var(--glass-border);
    }

    .toolbar-panel {
      pointer-events: auto;
      display: contents;
      /* Remove panel visual, just use as logical group */
    }

    .divider {
      width: 1px;
      height: 16px;
      background: rgba(0, 0, 0, 0.1);
      margin: 0 4px;
    }

    /* Buttons */
    .icon-btn,
    .main-button {
      padding: 4px 8px;
      background: transparent;
      color: var(--text-color);
      border: 1px solid transparent;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
      font-family: var(--font-family);
      transition: all 0.2s ease;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .icon-btn:hover,
    .main-button:hover {
      background: rgba(0, 0, 0, 0.05);
      border-color: rgba(0, 0, 0, 0.1);
    }

    .icon-btn:active,
    .main-button:active {
      transform: translateY(0);
    }

    .delete-button {
      color: #e74c3c;
      background: rgba(231, 76, 60, 0.1);
    }

    .delete-button:hover {
      background: rgba(231, 76, 60, 0.2);
      color: #c0392b;
    }

    .primary-btn {
      background: var(--primary-color);
      color: white;
    }

    .primary-btn:hover {
      background: #357abd;
      color: white;
    }

    /* Color Swatches */
    .color-swatch {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: transform 0.2s;
    }

    .color-swatch:hover {
      transform: scale(1.2);
    }

    /* Emoji Buttons */
    .emoji-btn {
      background: transparent;
      border: none;
      font-size: 16px;
      cursor: pointer;
      padding: 2px;
      border-radius: 4px;
      transition: background 0.2s;
    }

    .emoji-btn:hover {
      background: rgba(0, 0, 0, 0.05);
      transform: scale(1.1);
    }

    #upload-json {
      display: none;
    }

    /* Hide for print/export */
    @media print {
      #toolbar-dock {
        display: none;
      }

      body {
        background: white;
      }

      .node {
        box-shadow: none;
        border: 1px solid #ccc;
      }
    }

    /* Helper class for html2canvas export */
    body.exporting {
      background: white !important;
    }

    body.exporting .node {
      backdrop-filter: none !important;
      background: rgba(255, 255, 255, 1) !important;
      box-shadow: none !important;
      border: 1px solid #999 !important;
    }

    body.exporting #toolbar-dock {
      display: none !important;
    }

    /* Attribution */
    .attribution {
      font-size: 10px;
      color: rgba(0, 0, 0, 0.5);
      margin-left: auto;
      display: flex;
      align-items: center;
    }

    .attribution a {
      color: inherit;
      text-decoration: none;
      display: flex;
      align-items: center;
    }

    /* Modal Styling */
    #modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(4px);
    }

    #modal-box {
      background: white;
      padding: 24px;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      text-align: center;
      max-width: 400px;
      width: 90%;
      font-family: var(--font-family);
    }

    #modal-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 12px;
      color: var(--text-color);
    }

    #modal-message {
      font-size: 14px;
      color: #666;
      margin-bottom: 24px;
      line-height: 1.5;
    }

    .modal-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }

    .modal-btn {
      padding: 8px 16px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: all 0.2s;
    }

    .btn-cancel {
      background: #f3f4f6;
      color: #374151;
    }

    .btn-cancel:hover {
      background: #e5e7eb;
    }

    .btn-new-window {
      background: #e0f2fe;
      color: #0369a1;
    }

    .btn-new-window:hover {
      background: #bae6fd;
    }

    .btn-overwrite {
      background: #fee2e2;
      color: #b91c1c;
    }

    .btn-overwrite:hover {
      background: #fecaca;
    }

    /* URL Status Badge */
    #url-status {
      pointer-events: auto;
      padding: 4px 10px;
      border-radius: 6px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: auto;
      user-select: none;
    }

    #url-status.status-good {
      background: #d1fae5;
      color: #065f46;
    }

    #url-status.status-warning {
      background: #fef3c7;
      color: #92400e;
    }

    #url-status.status-error {
      background: #fee2e2;
      color: #991b1b;
    }

    #url-status:hover {
      opacity: 0.8;
    }

    #url-status .status-icon {
      font-size: 10px;
    }

    /* Link Icon Styling */
    .node-link-icon {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      margin-left: 8px;
      font-size: 14px;
      text-decoration: none;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      width: 20px;
      height: 20px;
      transition: all 0.2s;
      vertical-align: middle;
    }

    .node-link-icon:hover {
      background: rgba(255, 255, 255, 0.8);
      transform: scale(1.1);
    }

    .node-md-image {
      max-width: 150px;
      max-height: 150px;
      display: block;
      margin: 4px auto;
      border-radius: 4px;
    }

    /* Link/Image Modal Styles */
    #link-modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(2px);
    }

    #link-modal-box {
      background: white;
      padding: 24px;
      border-radius: 12px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      width: 350px;
      font-family: 'Inter', sans-serif;
    }

    #link-modal-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 16px;
      color: #333;
    }

    #link-url-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      margin-bottom: 16px;
      box-sizing: border-box;
    }

    .link-type-selector {
      display: flex;
      gap: 16px;
      margin-bottom: 20px;
    }

    .link-type-selector label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
      cursor: pointer;
    }

    .modal-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
    }

    .modal-btn {
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
      transition: background 0.2s;
    }

    .btn-cancel {
      background: #f0f0f0;
      color: #333;
    }

    .btn-cancel:hover {
      background: #e0e0e0;
    }

    .btn-delete {
      background: #fee2e2;
      color: #dc2626;
    }

    .btn-delete:hover {
      background: #fecaca;
    }

    .btn-primary {
      background: #2563eb;
      color: white;
    }

    .btn-primary:hover {
      background: #1d4ed8;
    }

    /* Copy Text Modal */
    #copy-text-modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 3000;
      justify-content: center;
      align-items: center;
      backdrop-filter: blur(2px);
    }

    #copy-text-modal-box {
      background: white;
      padding: 24px;
      border-radius: 16px;
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
      width: 500px;
      max-width: 90%;
      font-family: var(--font-family);
      display: flex;
      flex-direction: column;
    }

    #copy-text-textarea {
      width: 100%;
      height: 200px;
      padding: 12px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-family: 'Monaco', 'Courier New', monospace;
      font-size: 12px;
      resize: vertical;
      margin-bottom: 16px;
      box-sizing: border-box;
      white-space: pre;
      overflow-x: auto;
      background: #f9fafb;
      color: #333;
    }

    #copy-text-textarea:focus {
      outline: 2px solid var(--primary-color);
      background: #fff;
    }

    /* Mode Toggle Button */
    #mode-toggle-btn {
      font-weight: 600;
      min-width: 80px;
      border: 2px solid var(--primary-color);
    }

    #mode-toggle-btn.edit-mode {
      background: #10b981;
      color: white;
      border-color: #10b981;
    }

    #mode-toggle-btn.move-mode {
      background: #3b82f6;
      color: white;
      border-color: #3b82f6;
    }

    /* Visual feedback for modes */
    body.move-mode .node {
      cursor: move;
    }

    body.edit-mode .node {
      cursor: text;
    }

    body.move-mode .node[contenteditable="true"] {
      cursor: move !important;
    }

    /* Drop target highlighting */
    .node.drop-target {
      border: 3px dashed #10b981 !important;
      background: rgba(16, 185, 129, 0.1) !important;
      box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.2) !important;
    }

    .node.dragging {
      opacity: 0.5;
      cursor: grabbing !important;
    }

    /* Responsive toolbar for iPad */
    @media (max-width: 1024px) {
      #toolbar-dock {
        flex-wrap: wrap;
        max-width: 95%;
        gap: 6px;
        padding: 6px 10px;
      }

      .icon-btn,
      .main-button {
        min-width: 44px;
        min-height: 44px;
        padding: 10px 14px;
        font-size: 14px;
      }

      #mode-toggle-btn {
        min-width: 100px;
        order: -1;
        /* Show first on mobile */
      }

      /* Hide less essential tools on tablet */
      .hide-tablet {
        display: none !important;
      }

      /* Simplify color palette - show only 3 colors */
      #color-palette .color-swatch:nth-child(n+4) {
        display: none;
      }

      /* Simplify emojis - show only first 3 */
      #emoji-buttons .emoji-btn:nth-child(n+4) {
        display: none;
      }
    }

    /* Mobile responsive */
    @media (max-width: 768px) {

      /* Hide on mobile */
      .hide-mobile {
        display: none !important;
      }

      /* Show only 2 colors on mobile */
      #color-palette .color-swatch:nth-child(n+3) {
        display: none;
      }

      /* Show only 2 emojis on mobile */
      #emoji-buttons .emoji-btn:nth-child(n+3) {
        display: none;
      }

      /* Hide URL status on mobile */
      #url-status {
        display: none;
      }

      /* Make toolbar even more compact */
      #toolbar-dock {
        gap: 4px;
        padding: 4px 6px;
      }

      .icon-btn,
      .main-button {
        padding: 8px 10px;
        font-size: 13px;
      }
    }
  </style>

</head>

<body>
  <div id="mindmap-container">
    <div id="canvas-layer">
      <svg id="svg-connections"></svg>
      <!-- Central Node with Placeholder -->
      <div id="central-node" class="node central-node" contenteditable="true" tabindex="0"
        data-placeholder="Central topic"></div>
    </div>
    <div id="toolbar-dock">
      <!-- Main Actions -->
      <div class="toolbar-panel" id="main-actions"><button id="mode-toggle-btn" class="main-button move-mode"
          title="Toggle Move/Edit Mode">üîÑ Move</button>
        <div class="divider"></div><button id="add-node-btn" class="main-button primary-btn"
          title="Add Sibling (Enter)">+Node</button><button id="add-child-btn" class="main-button primary-btn"
          title="Add Child (Tab)">+Child</button><button id="delete-node-btn" class="main-button delete-button"
          title="Delete Selected">Del</button><button id="split-node-btn" class="icon-btn hide-mobile"
          title="Split into new Mindmap">‚úÇÔ∏è</button>
        <div class="divider"></div><button id="undo-btn" class="icon-btn hide-mobile" title="Undo">‚Ü©</button><button
          id="redo-btn" class="icon-btn hide-mobile" title="Redo">‚Ü™</button><button id="add-link-btn"
          class="icon-btn hide-mobile" title="Add/Edit Link">üîó</button><button id="copy-text-btn"
          class="icon-btn hide-tablet" title="Copy Text">üìã</button>
        <div class="divider"></div><button id="auto-layout-btn" class="icon-btn hide-mobile"
          title="Auto-layout nodes">üîÑ</button>
      </div>
      <!-- Styling & Emojis -->
      <div class="toolbar-panel" id="style-panel">
        <div class="divider"></div>
        <div id="color-palette" style="display: flex; gap: 4px; align-items: center;">
          <div class="color-swatch" style="background-color: #FFFFFF;" data-color="#FFFFFF"></div>
          <div class="color-swatch" style="background-color: #FFD700;" data-color="#FFD700"></div>
          <div class="color-swatch" style="background-color: #FF4500;" data-color="#FF4500"></div>
          <div class="color-swatch" style="background-color: #32CD32;" data-color="#32CD32"></div>
          <div class="color-swatch" style="background-color: #1E90FF;" data-color="#1E90FF"></div>
          <div class="color-swatch" style="background-color: #BA55D3;" data-color="#BA55D3"></div>
        </div>
        <div class="divider"></div>
        <div id="emoji-buttons" style="display: flex; gap: 1px;"><button class="emoji-btn"
            data-emoji="üí°">üí°</button><button class="emoji-btn" data-emoji="üß†">üß†</button><button class="emoji-btn"
            data-emoji="üìö">üìö</button><button class="emoji-btn" data-emoji="üéØ">üéØ</button><button class="emoji-btn"
            data-emoji="‚úÖ">‚úÖ</button><button class="emoji-btn" data-emoji="‚ùå">‚ùå</button><button class="emoji-btn"
            data-emoji="üõ†Ô∏è">üõ†Ô∏è</button><button class="emoji-btn" data-emoji="üö¶">üö¶</button><button class="emoji-btn"
            data-emoji="üé¨">üé¨</button></div>
      </div>
      <!-- File Operations -->
      <div class="toolbar-panel" id="file-ops">
        <div class="divider"></div><a href="mindmapplain.html" target="_blank" style="text-decoration: none;"><button
            class="main-button hide-tablet" title="New Mindmap">New</button></a><button id="upload-json-btn"
          class="main-button hide-tablet" onclick="document.getElementById('upload-json').click()"
          title="Open JSON">üìÇ</button><input type="file" id="upload-json" /><button id="download-json-btn"
          class="main-button" title="Save JSON">üíæ</button><button id="export-png-btn" class="main-button hide-tablet"
          title="Export PNG">üñºÔ∏è</button><button id="export-pptx-btn" class="main-button hide-tablet"
          title="Export PPTX">üìä</button><button id="help-btn" class="main-button" title="Help">‚ùì</button>
        <div class="attribution hide-tablet" style="margin-left: 8px;"><a
            href="https://creativecommons.org/licenses/by-nc-sa/4.0/?ref=chooser-v1" target="_blank"
            rel="license noopener noreferrer" title="CC BY-NC-SA 4.0"><img style="height:18px!important;"
              src="https://mirrors.creativecommons.org/presskit/icons/cc.svg?ref=chooser-v1" alt=""><img
              style="height:18px!important;"
              src="https://mirrors.creativecommons.org/presskit/icons/by.svg?ref=chooser-v1" alt=""><img
              style="height:18px!important;"
              src="https://mirrors.creativecommons.org/presskit/icons/nc.svg?ref=chooser-v1" alt=""><img
              style="height:18px!important;"
              src="https://mirrors.creativecommons.org/presskit/icons/sa.svg?ref=chooser-v1" alt=""></a></div>
        <div id="url-status" class="status-good" title="Click to toggle URL storage"><span
            class="status-icon">‚óè</span><span id="url-char-count">0</span></div>
      </div>
    </div>
  </div>



  <!-- Warning Modal -->
  <div id="modal-overlay">
    <div id="modal-box">
      <div id="modal-title">Open Mind Map</div>
      <div id="modal-message">Opening a file will overwrite your current mind map. What would you like to do?</div>
      <div class="modal-buttons"><button class="modal-btn btn-cancel" id="modal-cancel">Cancel</button><button
          class="modal-btn btn-new-window" id="modal-new-window">New Window</button><button
          class="modal-btn btn-overwrite" id="modal-overwrite">Overwrite</button></div>
    </div>
  </div>

  <!-- Link/Image Selection Modal -->
  <div id="link-modal-overlay">
    <div id="link-modal-box">
      <div id="link-modal-title">Add Link or Image</div>
      <div class="link-modal-content">
        <input type="text" id="link-url-input" placeholder="Enter URL (https://...)" />
        <div id="image-upload-container" style="display: none; margin-bottom: 10px;">
          <input type="file" id="image-file-input" accept="image/*" style="font-size: 14px;">
          <div style="font-size: 12px; color: #666; margin-top: 4px;">Or paste URL above. Uploaded images are embedded.
          </div>
        </div>
        <div class="link-type-selector">
          <label><input type="radio" name="link-type" value="link" checked> Hyperlink</label>
          <label><input type="radio" name="link-type" value="image"> Image</label>
        </div>
        <div id="image-size-container" style="display: none; margin-bottom: 20px;">
          <label for="image-size-slider" style="display: block; font-size: 14px; margin-bottom: 8px;">Image Size: <span
              id="image-size-value">150</span>px</label>
          <input type="range" id="image-size-slider" min="10" max="150" value="150" style="width: 100%;">
        </div>
      </div>
      <div class="modal-buttons">
        <button class="modal-btn btn-cancel" id="link-modal-cancel">Cancel</button>
        <button class="modal-btn btn-delete" id="link-modal-remove">Remove</button>
        <button class="modal-btn btn-primary" id="link-modal-save">Save</button>
      </div>
    </div>
  </div>

  <!-- Copy Text Modal -->
  <div id="copy-text-modal-overlay">
    <div id="copy-text-modal-box">
      <div id="modal-title" style="text-align: left;">Copy Mind Map Text</div>
      <div style="font-size: 13px; color: #666; margin-bottom: 12px; text-align: left;">
        Copy the text below or open it in the text editor to make bulk changes.
      </div>
      <textarea id="copy-text-textarea" readonly></textarea>
      <div class="modal-buttons" style="justify-content: flex-end;">
        <button class="modal-btn btn-cancel" id="copy-text-cancel">Cancel</button>
        <button class="modal-btn btn-new-window" id="copy-text-export">Open in Text Editor</button>
        <button class="modal-btn btn-primary" id="copy-text-clipboard">Copy to Clipboard</button>
      </div>
    </div>
  </div>
  <script>    const container = document.getElementById('mindmap-container');
    const canvasLayer = document.getElementById('canvas-layer');
    const svg = document.getElementById('svg-connections');
    const centralNode = document.getElementById('central-node');
    const documentTitle = document.getElementById('document-title');
    const copyTextBtn = document.getElementById('copy-text-btn');
    const deleteNodeBtn = document.getElementById('delete-node-btn');
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');
    const addLinkBtn = document.getElementById('add-link-btn');
    const addNodeBtn = document.getElementById('add-node-btn');
    const addChildBtn = document.getElementById('add-child-btn');
    const exportPngBtn = document.getElementById('export-png-btn');
    const buttonContainer = document.getElementById('toolbar-dock');
    const colorPalette = document.getElementById('color-palette');
    const emojiButtons = document.querySelectorAll('.emoji-btn');

    const colors = ['#FFFFFF',
      '#FFD700',
      '#FF4500',
      '#32CD32',
      '#1E90FF',
      '#BA55D3'];

    let nodesData = [];
    let undoStack = [];
    let redoStack = [];
    let selectedNodeId = null;
    let siblingAngle = 0; // Angle to track placement for sibling nodes

    let parentChildAngles = {}; // Track next angle for each parent's children
    let urlStorageEnabled = true; // Toggle for URL storage
    let isInitialized = false; // Prevent URL updates before initial load
    let interactionMode = 'move'; // 'move' or 'edit' - for iPad usability

    // Panning State
    let panX = 0;
    let panY = 0;
    let isPanning = false;
    let panStartX = 0;
    let panStartY = 0;

    function updateCanvasTransform() {
      if (canvasLayer) {
        // Use 3D transform for hardware acceleration
        canvasLayer.style.transform = `translate3d(${panX}px, ${panY}px, 0)`;
      }
    }

    // Initialize Panning Listeners
    container.addEventListener('mousedown', (e) => {
      // Only start panning if clicking on background or canvas layer directly
      // And avoid panning if clicking buttons/inputs
      if (e.target === container || e.target === canvasLayer || e.target === svg || e.target.tagName === 'svg') {
        isPanning = true;
        panStartX = e.clientX - panX;
        panStartY = e.clientY - panY;
        container.style.cursor = 'grabbing';
      }
    });

    window.addEventListener('mousemove', (e) => {
      if (isPanning) {
        e.preventDefault();
        panX = e.clientX - panStartX;
        panY = e.clientY - panStartY;
        updateCanvasTransform();
      }
    });

    window.addEventListener('mouseup', () => {
      if (isPanning) {
        isPanning = false;
        container.style.cursor = 'grab';
      }
    });

    // Touch Support for iPad/Mobile Panning
    container.addEventListener('touchstart', (e) => {
      if (e.target === container || e.target === canvasLayer || e.target === svg || e.target.tagName === 'svg') {
        const touch = e.touches[0];
        isPanning = true;
        panStartX = touch.clientX - panX;
        panStartY = touch.clientY - panY;
      }
    }, { passive: false });

    window.addEventListener('touchmove', (e) => {
      if (isPanning) {
        e.preventDefault(); // Prevent native scrolling
        const touch = e.touches[0];
        panX = touch.clientX - panStartX;
        panY = touch.clientY - panStartY;
        updateCanvasTransform();
      }
    }, { passive: false });

    window.addEventListener('touchend', () => {
      if (isPanning) {
        isPanning = false;
      }
    });

    // Mouse wheel to pan? (Optional, maybe for another time. Standard is drag)

    function generateId() {
      return 'node-' + Math.random().toString(36).substr(2, 9);
    }

    // Initialize central node with fixed ID and empty text
    const centralNodeId = 'central-node';

    // Initialize central node at center of viewport
    const containerRect = container.getBoundingClientRect();
    const centerX = containerRect.width / 2 - 80; // Offset by approximate half node width
    const centerY = containerRect.height / 2 - 40; // Offset by approximate half node height

    nodesData.push({
      id: centralNodeId,
      parentId: null,
      x: centerX,
      y: centerY,
      color: colors[0],
      text: '' // Empty text for central node to show placeholder
    });

    function updateDocumentTitle() {
      const centralNodeData = nodesData.find(n => n.id === centralNodeId);

      if (centralNodeData) {
        documentTitle.textContent = centralNodeData.text || 'Mind Map';
      }
    }

    // Mode Toggle Functions for iPad usability
    function toggleMode() {
      interactionMode = interactionMode === 'move' ? 'edit' : 'move';
      updateModeUI();
      localStorage.setItem('mindmap-interaction-mode', interactionMode);
    }

    function updateModeUI() {
      const modeBtn = document.getElementById('mode-toggle-btn');
      const allNodes = document.querySelectorAll('.node');

      if (interactionMode === 'edit') {
        // Edit Mode
        modeBtn.textContent = '‚úèÔ∏è Edit';
        modeBtn.className = 'main-button edit-mode';
        modeBtn.title = 'Switch to Move Mode';
        document.body.className = 'edit-mode';

        // Enable contenteditable
        allNodes.forEach(node => {
          node.contentEditable = 'true';
        });
      } else {
        // Move Mode
        modeBtn.textContent = 'üîÑ Move';
        modeBtn.className = 'main-button move-mode';
        modeBtn.title = 'Switch to Edit Mode';
        document.body.className = 'move-mode';

        // Disable contenteditable
        allNodes.forEach(node => {
          node.contentEditable = 'false';
        });
      }
    }

    function renderMindMap() {
      console.log('renderMindMap called, nodesData:', nodesData);
      // Clear dynamic nodes from canvasLayer (preserve central node and svg)
      const existingNodes = canvasLayer.querySelectorAll('.node');

      existingNodes.forEach(node => {
        if (node.id !== 'central-node') {
          canvasLayer.removeChild(node);
        }
      });

      nodesData.forEach(node => {
        if (node.id === centralNodeId) {
          centralNode.style.left = `${node.x}px`;
          centralNode.style.top = `${node.y}px`;
          centralNode.style.backgroundColor = node.color;

          // Use renderNodeContent for central node too
          renderNodeContent(centralNode, node, false);

          // Attach event listeners if not already attached
          if (!centralNode.dataset.listenersAttached) {
            addEventListenersToNode(centralNode, node.id);
            centralNode.dataset.listenersAttached = 'true';
          }

          return;
        }

        const nodeDiv = document.createElement('div');
        nodeDiv.className = 'node';
        nodeDiv.id = node.id;
        nodeDiv.contentEditable = true;
        nodeDiv.tabIndex = 0;

        nodeDiv.style.left = `${node.x}px`;
        nodeDiv.style.top = `${node.y}px`;
        nodeDiv.style.backgroundColor = node.color;

        // Initial render in View Mode
        renderNodeContent(nodeDiv, node, false);

        addEventListenersToNode(nodeDiv, node.id);
        canvasLayer.appendChild(nodeDiv);
      });

      drawConnections();
      highlightSelectedNode();
      updateDocumentTitle();
      updateURL();
      updateModeUI(); // Apply current mode to all nodes
      updateCanvasTransform();
    }

    function addEventListenersToNode(nodeDiv, nodeId) {
      nodeDiv.addEventListener('click', (e) => {
        e.stopPropagation(); // Prevent triggering container's click
        setSelectedNode(nodeId);
      });

      nodeDiv.addEventListener('keydown', (e) => handleKeyDown(e, nodeId));

      nodeDiv.addEventListener('mousedown', (e) => {
        // On desktop (non-touch), allow dragging in both modes
        // On touch devices, only allow dragging in move mode
        const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        if (interactionMode === 'move' || !isTouchDevice) {
          startDrag(e);
        }
      });

      // Add touch event listener for iPad/mobile
      nodeDiv.addEventListener('touchstart', (e) => {
        // Only allow dragging in move mode on touch devices
        if (interactionMode === 'move') {
          startDrag(e);
        }
      });

      nodeDiv.addEventListener('input', () => updateNodeText(nodeId));

      // Toggle between edit and view mode to prevent duplicate icons
      nodeDiv.addEventListener('focus', () => {
        const node = nodesData.find(n => n.id === nodeId);
        if (node) renderNodeContent(nodeDiv, node, true);
      });

      nodeDiv.addEventListener('blur', () => {
        const node = nodesData.find(n => n.id === nodeId);
        if (node) renderNodeContent(nodeDiv, node, false);
      });
    }

    function handleKeyDown(event, nodeId) {
      const isCentralNode = nodeId === centralNodeId;

      if (event.key === 'Enter') {
        event.preventDefault();

        if (isCentralNode) {
          addNode(nodeId);
        }

        else {
          addSiblingNode(nodeId);
        }
      }

      else if (event.key === 'Tab') {
        event.preventDefault();
        addNode(nodeId);
      }
    }

    function setSelectedNode(nodeId) {
      selectedNodeId = nodeId;
      highlightSelectedNode();
    }

    function highlightSelectedNode() {
      const allNodes = document.querySelectorAll('.node');
      allNodes.forEach(nodeDiv => {
        if (nodeDiv.id === selectedNodeId) {
          const node = nodesData.find(n => n.id === selectedNodeId);
          if (node) {
            if (node.link || node.image) {
              nodeDiv.style.borderColor = '#3b82f6'; // Blue for links/images
              nodeDiv.style.boxShadow = '0 0 0 2px rgba(59, 130, 246, 0.3)';
            } else {
              nodeDiv.style.borderColor = '#10b981'; // Green for text only
              nodeDiv.style.boxShadow = '0 0 0 2px rgba(16, 185, 129, 0.3)';
            }
          }
        } else {
          // Reset to default
          nodeDiv.style.borderColor = '';
          nodeDiv.style.boxShadow = '';
        }
      });
    }

    function addNode(parentId) {
      if (!parentId) {
        alert('No parent node selected.');
        return;
      }

      const newId = generateId();
      const nodeDiv = document.getElementById(parentId);

      // Use larger radius - 280px for central node children, 200px for others
      const radius = parentId === centralNodeId ? 280 : 200;

      const parentX = nodeDiv.offsetLeft;
      const parentY = nodeDiv.offsetTop;

      // Initialize angle tracking for this parent if not exists
      if (!parentChildAngles[parentId]) {
        parentChildAngles[parentId] = 0; // Start at 0 degrees (3 o'clock)
      }

      // Get existing children of this parent to find the best angle
      const existingChildren = nodesData.filter(n => n.parentId === parentId);

      // Calculate angle - distribute evenly around the parent
      // Start at 0¬∞ (right) and increment by 45¬∞ for each child
      let angle = parentChildAngles[parentId];
      let attempts = 0;
      const maxAttempts = 8; // Try up to 8 positions (every 45¬∞)

      // Find a non-overlapping position
      while (attempts < maxAttempts) {
        let newX = parentX + radius * Math.cos(angle * Math.PI / 180);
        let newY = parentY + radius * Math.sin(angle * Math.PI / 180);

        // Constrain the Y position
        const containerRect = container.getBoundingClientRect();
        newY = Math.max(100, Math.min(newY, containerRect.height - 100));

        // Check if this position overlaps with existing children
        const overlaps = existingChildren.some(child => {
          const dx = child.x - newX;
          const dy = child.y - newY;
          const distance = Math.sqrt(dx * dx + dy * dy);
          return distance < 120; // Minimum distance between nodes (increased from 80)
        });

        if (!overlaps) {

          // Found a good position
          const newNode = {
            id: newId,
            parentId: parentId,
            x: newX,
            y: newY,
            color: colors[0],
            text: ''
          }

            ;

          // Update angle for next child
          parentChildAngles[parentId] = (angle + 45) % 360;

          pushToUndo();
          nodesData.push(newNode);
          renderMindMap();
          focusNode(newId);
          return;
        }

        // Try next angle
        angle = (angle + 45) % 360;
        attempts++;
      }

      // If all positions tried, just place it at the current angle anyway
      let newX = parentX + radius * Math.cos(angle * Math.PI / 180);
      let newY = parentY + radius * Math.sin(angle * Math.PI / 180);
      const containerRect = container.getBoundingClientRect();
      newY = Math.max(100, Math.min(newY, containerRect.height - 100));

      const newNode = {
        id: newId,
        parentId: parentId,
        x: newX,
        y: newY,
        color: colors[0],
        text: ''
      }

        ;

      parentChildAngles[parentId] = (angle + 45) % 360;

      pushToUndo();
      nodesData.push(newNode);
      renderMindMap();
      focusNode(newId);
    }


    function addSiblingNode(currentNodeId) {
      const currentNode = nodesData.find(n => n.id === currentNodeId);
      if (!currentNode) return;

      const siblingRadius = 200;
      let siblingX = currentNode.x + siblingRadius * Math.cos(siblingAngle * Math.PI / 180);
      let siblingY = currentNode.y + siblingRadius * Math.sin(siblingAngle * Math.PI / 180);
      siblingAngle += 45;

      // Constrain the Y position of the new sibling node
      const containerRect = container.getBoundingClientRect();
      siblingY = Math.max(100, Math.min(siblingY, containerRect.height - 100)); // Prevent creation too high or too low

      const newId = generateId();

      const newNode = {
        id: newId,
        parentId: currentNode.parentId,
        x: siblingX,
        y: siblingY,
        color: colors[0],
        text: ''
      }

        ;
      pushToUndo();
      nodesData.push(newNode);
      renderMindMap();
      focusNode(newId);
    }


    function deleteSelectedNode() {
      if (!selectedNodeId) {
        alert('No node selected for deletion.');
        return;
      }

      if (selectedNodeId === centralNodeId) {
        alert('Cannot delete the central node.');
        return;
      }

      pushToUndo();

      function deleteRecursively(id) {
        const children = nodesData.filter(n => n.parentId === id);
        children.forEach(child => deleteRecursively(child.id));
        nodesData = nodesData.filter(n => n.id !== id);
      }

      deleteRecursively(selectedNodeId);
      selectedNodeId = null;
      renderMindMap();
    }

    function changeNodeColor(color) {
      if (!selectedNodeId) return;
      const node = nodesData.find(n => n.id === selectedNodeId);

      if (node) {
        pushToUndo();
        node.color = color;
        renderMindMap();
      }
    }

    function updateNodeText(nodeId) {
      const node = nodesData.find(n => n.id === nodeId);
      const nodeDiv = document.getElementById(nodeId);
      if (node && nodeDiv) {
        // In Edit Mode (which triggers input), innerText is the raw text.
        // We don't need to filter out the link icon because it's not rendered in Edit Mode.
        node.text = nodeDiv.innerText;
        updateDocumentTitle();
        updateURL();
      }
    }

    function renderNodeContent(nodeDiv, node, editMode) {
      console.log('renderNodeContent called:', { nodeId: node.id, text: node.text, editMode });
      if (editMode) {
        // Edit Mode: Raw text
        nodeDiv.innerText = node.text;

        // Apply selection style immediately for edit mode
        if (node.link || node.image) {
          nodeDiv.style.borderColor = '#3b82f6'; // Blue
        } else {
          nodeDiv.style.borderColor = '#10b981'; // Green
        }
      } else {
        // View Mode: Plain text + Image + Link Icon
        // Set text FIRST before clearing to prevent updateNodeText from seeing empty content
        if (node.text) {
          nodeDiv.textContent = node.text;
          console.log('Text content set:', node.text);
        } else {
          nodeDiv.textContent = '';
          console.log('No text to set for node:', node.id);
        }

        // Now add images and links as additional children
        // Reset border color to default in view mode (highlightSelectedNode handles selection)
        nodeDiv.style.borderColor = '';

        // Render Image if present
        if (node.image) {
          const img = document.createElement('img');
          img.src = node.image;
          img.className = 'node-md-image';
          img.alt = 'Node Image';
          img.contentEditable = 'false';

          // Apply custom size if exists
          if (node.imageSize) {
            img.style.maxWidth = node.imageSize + 'px';
            img.style.maxHeight = node.imageSize + 'px';
          }

          nodeDiv.appendChild(img);
        }

        // Render Link Icon if present
        if (node.link) {
          const linkIcon = document.createElement('a');
          linkIcon.href = node.link;
          linkIcon.target = '_blank';
          linkIcon.className = 'node-link-icon';
          linkIcon.innerHTML = 'üîó';
          linkIcon.contentEditable = 'false';
          linkIcon.title = node.link;

          linkIcon.addEventListener('click', (e) => {
            e.stopPropagation();
            // Link opens via href attribute, no need for window.open()
          });

          nodeDiv.appendChild(linkIcon);
        }
      }
    }

    function pushToUndo() {
      undoStack.push(JSON.parse(JSON.stringify(nodesData)));
      redoStack = [];
    }

    function undo() {
      if (undoStack.length === 0) return;
      redoStack.push(JSON.parse(JSON.stringify(nodesData)));
      nodesData = undoStack.pop();
      renderMindMap();
    }

    function redo() {
      if (redoStack.length === 0) return;
      undoStack.push(JSON.parse(JSON.stringify(nodesData)));
      nodesData = redoStack.pop();
      renderMindMap();
    }

    let isDraggingFlag = false;
    let currentDraggedNodeId = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;
    let currentDropTarget = null;

    function startDrag(event) {
      if (event.target.classList.contains('node')) {
        isDraggingFlag = true;
        currentDraggedNodeId = event.target.id;
        const nodeRect = event.target.getBoundingClientRect();
        const containerRect = container.getBoundingClientRect();

        // Handle both mouse and touch events
        const clientX = event.clientX || (event.touches && event.touches[0].clientX);
        const clientY = event.clientY || (event.touches && event.touches[0].clientY);

        dragOffsetX = clientX - nodeRect.left;
        dragOffsetY = clientY - nodeRect.top;

        // Add visual feedback for dragging
        event.target.classList.add('dragging');

        // Add both mouse and touch event listeners
        document.addEventListener('mousemove', dragNode);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchmove', dragNode);
        document.addEventListener('touchend', stopDrag);
      }
    }

    function dragNode(event) {
      if (!isDraggingFlag || !currentDraggedNodeId) return;

      // Prevent default touch behavior (scrolling)
      if (event.type === 'touchmove') {
        event.preventDefault();
      }

      const containerRect = container.getBoundingClientRect();

      // Handle both mouse and touch events
      const clientX = event.clientX || (event.touches && event.touches[0].clientX);
      const clientY = event.clientY || (event.touches && event.touches[0].clientY);

      // Calculate new position relative to container, then subtract pan offset
      let newX = clientX - containerRect.left - dragOffsetX - panX;
      let newY = clientY - containerRect.top - dragOffsetY - panY;

      // Removed strict bounds to allow infinite canvas
      // But let's keep a tiny safety buffer so you can't lose it entirely? 
      // Actually, infinite needs no bounds. 
      // Maybe just prevent negative coords if we want top-left to be origin, 
      // but for true infinite, negative coords are fine if handled correctly.
      // For now, let's allow negative coords to support expanding left/top.

      const node = nodesData.find(n => n.id === currentDraggedNodeId);

      if (node) {
        node.x = newX;
        node.y = newY;
        renderMindMap();
      }

      // Check if we're hovering over another node (potential drop target)
      if (interactionMode === 'move') {
        const allNodes = document.querySelectorAll('.node');
        let foundTarget = null;

        allNodes.forEach(nodeDiv => {
          // Skip the dragged node itself
          if (nodeDiv.id === currentDraggedNodeId) return;

          const rect = nodeDiv.getBoundingClientRect();
          if (clientX >= rect.left && clientX <= rect.right &&
            clientY >= rect.top && clientY <= rect.bottom) {
            foundTarget = nodeDiv;
          }
        });

        // Update drop target highlighting
        if (foundTarget !== currentDropTarget) {
          // Remove highlight from previous target
          if (currentDropTarget) {
            currentDropTarget.classList.remove('drop-target');
          }
          // Add highlight to new target
          if (foundTarget) {
            foundTarget.classList.add('drop-target');
          }
          currentDropTarget = foundTarget;
        }
      }
    }


    function stopDrag() {
      // Handle reparenting if dropped on another node
      if (currentDropTarget && currentDraggedNodeId && interactionMode === 'move') {
        const targetNodeId = currentDropTarget.id;
        const draggedNode = nodesData.find(n => n.id === currentDraggedNodeId);

        // Prevent making a node its own parent or creating circular dependencies
        if (targetNodeId !== currentDraggedNodeId && !isDescendant(targetNodeId, currentDraggedNodeId)) {
          // Update the parent relationship
          if (draggedNode) {
            draggedNode.parentId = targetNodeId;

            // Optionally reposition the node near its new parent
            const targetNode = nodesData.find(n => n.id === targetNodeId);
            if (targetNode) {
              // Position it to the right of the new parent
              draggedNode.x = targetNode.x + 200;
              draggedNode.y = targetNode.y;
            }

            saveState();
            renderMindMap();
          }
        }
      }

      // Clean up
      if (currentDropTarget) {
        currentDropTarget.classList.remove('drop-target');
        currentDropTarget = null;
      }

      if (currentDraggedNodeId) {
        const draggedElement = document.getElementById(currentDraggedNodeId);
        if (draggedElement) {
          draggedElement.classList.remove('dragging');
        }
      }

      isDraggingFlag = false;
      currentDraggedNodeId = null;
      document.removeEventListener('mousemove', dragNode);
      document.removeEventListener('mouseup', stopDrag);
      document.removeEventListener('touchmove', dragNode);
      document.removeEventListener('touchend', stopDrag);
      updateURL();
    }

    // Helper function to check if a node is a descendant of another
    function isDescendant(potentialDescendantId, ancestorId) {
      let currentNode = nodesData.find(n => n.id === potentialDescendantId);

      while (currentNode && currentNode.parentId) {
        if (currentNode.parentId === ancestorId) {
          return true;
        }
        currentNode = nodesData.find(n => n.id === currentNode.parentId);
      }

      return false;
    }

    function focusNode(nodeId) {
      const nodeDiv = document.getElementById(nodeId);

      if (nodeDiv) {
        nodeDiv.focus();
        setSelectedNode(nodeId);
      }
    }

    function drawConnections() {
      // Reverting to original simple logic for screen display consistency
      // The heavy lifting for large maps is now done in the export function
      svg.innerHTML = '';

      nodesData.forEach(node => {
        if (node.parentId) {
          const parentNode = nodesData.find(n => n.id === node.parentId);

          if (parentNode) {
            drawLine(parentNode, node);
          }
        }
      });
    }

    function drawLine(parent, child) {
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      // Original offsets that worked well for the screen
      line.setAttribute('x1', parent.x + 50);
      line.setAttribute('y1', parent.y + 30);
      line.setAttribute('x2', child.x + 50);
      line.setAttribute('y2', child.y + 30);
      line.setAttribute('stroke', 'rgba(0, 0, 0, 0.4)');
      line.setAttribute('stroke-width', '2');
      svg.appendChild(line);
    }

    function updateURL() {
      console.log('updateURL called, nodesData:', nodesData);
      if (!isInitialized) {
        console.log('updateURL skipped: not initialized');
        return;
      }
      if (!urlStorageEnabled) {
        updateURLStatus(0, false);
        return;
      }

      const serializedData = JSON.stringify(nodesData);
      const encodedData = btoa(encodeURIComponent(serializedData));
      const fullURL = '#' + encodedData;
      console.log('updateURL encoding:', serializedData);

      window.history.replaceState(null, null, fullURL);
      updateURLStatus(fullURL.length, true);
    }

    function updateURLStatus(charCount, enabled) {
      const statusBadge = document.getElementById('url-status');
      const charCountEl = document.getElementById('url-char-count');

      if (!enabled) {
        statusBadge.className = 'status-good';
        statusBadge.title = 'URL storage disabled (click to enable)';
        charCountEl.textContent = 'OFF';
        return;
      }

      charCountEl.textContent = charCount;

      // Color coding based on safe limits
      if (charCount < 2000) {
        statusBadge.className = 'status-good';

        statusBadge.title = `URL: $ {
          charCount
        }

        chars (Safe for all browsers)`;
      }

      else if (charCount < 8000) {
        statusBadge.className = 'status-warning';

        statusBadge.title = `URL: $ {
          charCount
        }

        chars (May have issues in some contexts)`;
      }

      else {
        statusBadge.className = 'status-error';

        statusBadge.title = `URL: $ {
          charCount
        }

        chars (Too long ! Consider saving as JSON)`;
      }
    }

    // Toggle URL storage
    document.getElementById('url-status').addEventListener('click', () => {
      urlStorageEnabled = !urlStorageEnabled;

      if (urlStorageEnabled) {
        updateURL(); // Re-enable and update
      }

      else {
        window.history.replaceState(null, null, window.location.pathname);
        updateURLStatus(0, false);
      }
    });

    function generateMindMapText(nodeId, depth = 0) {
      const node = nodesData.find(n => n.id === nodeId);
      if (!node) return '';

      let text = '';
      // Don't indent the central node (depth 0)
      // Actually, for the copy text format, we usually want the central node at the top
      // and children indented.

      const indent = '\t'.repeat(depth);
      text += `${indent}${node.text}\n`;

      // Find children
      const children = nodesData.filter(n => n.parentId === nodeId);

      // Sort children by vertical position (y) to maintain visual order
      children.sort((a, b) => a.y - b.y);

      children.forEach(child => {
        text += generateMindMapText(child.id, depth + 1);
      });

      return text;
    }

    function copyText() {
      // Use DFS to generate text in correct order
      // Start with central node
      const textToCopy = generateMindMapText(centralNodeId, 0).trim();

      const modal = document.getElementById('copy-text-modal-overlay');
      const textarea = document.getElementById('copy-text-textarea');

      textarea.value = textToCopy;
      modal.style.display = 'flex';

      // Select all text for easy copying
      textarea.select();
    }

    function splitNode() {
      if (!selectedNodeId) {
        alert('No node selected to split.');
        return;
      }

      if (selectedNodeId === centralNodeId) {
        alert('Cannot split the central node.');
        return;
      }

      const selectedNode = nodesData.find(n => n.id === selectedNodeId);
      if (!selectedNode) return;

      // 1. Find all descendants
      const descendants = [];
      const stack = [selectedNodeId];
      const visited = new Set();

      while (stack.length > 0) {
        const currentId = stack.pop();
        if (visited.has(currentId)) continue;
        visited.add(currentId);

        // Find children of currentId
        const children = nodesData.filter(n => n.parentId === currentId);
        children.forEach(child => {
          descendants.push(child);
          stack.push(child.id);
        });
      }

      // 2. Create new node list
      // The selected node becomes the new central node
      const newCentralNode = {
        ...selectedNode,
        id: 'central-node',
        parentId: null,
        x: 0,
        y: 0
      };

      // Map old IDs to new IDs if we wanted to be super clean, but keeping IDs (except central) is fine
      // providing we update the parentId of the direct children.

      const newNodes = [newCentralNode];

      descendants.forEach(node => {
        const newNode = { ...node };
        if (newNode.parentId === selectedNodeId) {
          newNode.parentId = 'central-node';
        }
        newNodes.push(newNode);
      });

      // 3. Serialize and Open
      const serializedData = JSON.stringify(newNodes);
      const encodedData = btoa(encodeURIComponent(serializedData));
      const fullURL = window.location.pathname + '#' + encodedData;

      window.open(fullURL, '_blank');
    }

    // Copy Text Modal Event Listeners
    document.getElementById('copy-text-cancel').addEventListener('click', () => {
      document.getElementById('copy-text-modal-overlay').style.display = 'none';
    });

    document.getElementById('copy-text-clipboard').addEventListener('click', () => {
      const textarea = document.getElementById('copy-text-textarea');
      textarea.select();

      navigator.clipboard.writeText(textarea.value).then(() => {
        const originalText = document.getElementById('copy-text-clipboard').textContent;
        document.getElementById('copy-text-clipboard').textContent = 'Copied!';
        setTimeout(() => {
          document.getElementById('copy-text-clipboard').textContent = originalText;
          document.getElementById('copy-text-modal-overlay').style.display = 'none';
        }, 1000);
      }).catch(err => {
        console.error('Failed to copy text: ', err);
        alert('Failed to copy text to clipboard');
      });
    });

    document.getElementById('copy-text-export').addEventListener('click', () => {
      const textarea = document.getElementById('copy-text-textarea');
      const fullText = textarea.value;

      // Parse the text to separate central topic from nodes
      const lines = fullText.split('\n');
      if (lines.length === 0) return;

      const centralTopic = lines[0].trim();

      // Get the rest of the lines and un-indent them by one level
      // because exportmm expects children of central node to be indented once?
      // Actually exportmm expects:
      // Central Topic (input field)
      // Nodes (textarea):
      //   Child 1
      //     Grandchild 1

      // Our generateMindMapText produces:
      // Central Topic
      //   Child 1
      //     Grandchild 1

      // So we need to take lines 1..n and remove one tab from the start of each
      const nodeLines = lines.slice(1).map(line => {
        if (line.startsWith('\t')) {
          return line.substring(1);
        }
        return line;
      });

      const nodesText = nodeLines.join('\n');

      // Encode for URL
      const encodedNodes = btoa(unescape(encodeURIComponent(nodesText)));

      const url = `exportmm.html?title=${encodeURIComponent(centralTopic)}&nodes_b64=${encodedNodes}`;
      window.open(url, '_blank');

      document.getElementById('copy-text-modal-overlay').style.display = 'none';
    });

    function getNodeDepth(nodeId, depth = 0) {
      const node = nodesData.find(n => n.id === nodeId);

      if (node && node.parentId) {
        return getNodeDepth(node.parentId, depth + 1);
      }

      return depth;
    }

    function init() {
      // Initialize interaction mode based on device type
      const savedMode = localStorage.getItem('mindmap-interaction-mode');
      const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      interactionMode = savedMode || (isTouchDevice ? 'move' : 'edit');

      loadFromURL();
      // Re-query central node as it might have been re-created by renderMindMap
      const currentCentralNode = document.getElementById(centralNodeId);

      if (currentCentralNode) {
        currentCentralNode.focus();
      }

      setSelectedNode(centralNodeId);
      updateModeUI(); // Apply initial mode
    }

    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      setTimeout(init, 1);
    } else {
      window.addEventListener('DOMContentLoaded', init);
    }

    window.addEventListener('beforeunload', () => {
      updateURL();
    });

    window.addEventListener('resize', () => {
      renderMindMap();
    });

    // Event listeners for main buttons
    document.getElementById('mode-toggle-btn').addEventListener('click', toggleMode);
    copyTextBtn.addEventListener('click', copyText);
    deleteNodeBtn.addEventListener('click', deleteSelectedNode);
    document.getElementById('split-node-btn').addEventListener('click', splitNode);
    undoBtn.addEventListener('click', undo);
    redoBtn.addEventListener('click', redo);
    addLinkBtn.addEventListener('click', addLink);
    addNodeBtn.addEventListener('click', () => addSiblingNode(selectedNodeId));
    addChildBtn.addEventListener('click', () => addNode(selectedNodeId));
    document.getElementById('download-json-btn').addEventListener('click', downloadJSON);
    document.getElementById('auto-layout-btn').addEventListener('click', autoLayout);
    document.getElementById('help-btn').addEventListener('click', () => window.open('help.html', '_blank'));

    function loadTutorial(force = false) {

      // Encode tutorial data and open in new window with URL hash
      const tutorialData = [{
        "id": "central-node", "parentId": null, "x": 594, "y": 378, "color": "#FFFFFF", "text": "How to use"
      }

        ,
      {
        "id": "node-itx7aweuu", "parentId": "central-node", "x": 606.984375, "y": 113.0859375, "color": "#32CD32", "text": "Use Tab to make child nodes"
      }

        ,
      {
        "id": "node-v8wicqt4z", "parentId": "central-node", "x": 684, "y": 191.0859375, "color": "#32CD32", "text": "Use Enter to add siblings"
      }

        ,
      {
        "id": "node-urm2xi9fn", "parentId": "central-node", "x": 230.984375, "y": 376.0859375, "color": "#FFD700", "text": "Press the icons for colours and emojis"
      }

        ,
      {
        "id": "node-vfc52uqw1", "parentId": "node-urm2xi9fn", "x": 194, "y": 487.0859375, "color": "#FFFFFF", "text": "üí°Idea"
      }

        ,
      {
        "id": "node-4vwecjmln", "parentId": "node-urm2xi9fn", "x": 370, "y": 254.0961894323342, "color": "#FFFFFF", "text": "üß†Thinking"
      }

        ,
      {
        "id": "node-b01ouqdyi", "parentId": "node-urm2xi9fn", "x": 325, "y": 493.0859375, "color": "#FFFFFF", "text": "üî¨research"
      }

        ,
      {
        "id": "node-rbvu3wcl7", "parentId": "node-urm2xi9fn", "x": 201.9965362548828, "y": 254.0885467529297, "color": "#FFFFFF", "text": "üéØTarget"
      }

        ,
      {
        "id": "node-nw6o6pwa8", "parentId": "node-urm2xi9fn", "x": 31, "y": 401.0859375, "color": "#FFFFFF", "text": "‚úÖDone"
      }

        ,
      {
        "id": "node-zmdqet6c5", "parentId": "node-urm2xi9fn", "x": 26, "y": 485.0859375, "color": "#FFFFFF", "text": "‚ùåNot done"
      }

        ,
      {
        "id": "node-4y5fi21ud", "parentId": "node-urm2xi9fn", "x": 483.9921875, "y": 491.0859375, "color": "#FFFFFF", "text": "üõ†Ô∏èFix it"
      }

        ,
      {
        "id": "node-eicb2ehb7", "parentId": "node-urm2xi9fn", "x": 15, "y": 311.0859375, "color": "#FFFFFF", "text": "üö¶Progress"
      }

        ,
      {
        "id": "node-d5wucmwhk", "parentId": "node-urm2xi9fn", "x": 297.9930725097656, "y": 163.0885467529297, "color": "#FFFFFF", "text": "üé¨Action"
      }

        ,
      {
        "id": "node-xp19w7q95", "parentId": "node-urm2xi9fn", "x": 43.984375, "y": 585.078125, "color": "#FFFFFF", "text": "Can change icon by pressing another button"
      }

        ,
      {
        "id": "node-rfh741ueh", "parentId": "central-node", "x": 848, "y": 448.078125, "color": "#FFFFFF", "text": "Copy Text gives you the mindmap text"
      }

        ,
      {
        "id": "node-q23udh75a", "parentId": "central-node", "x": 923.9921875, "y": 259.0859375, "color": "#FFFFFF", "text": "The link at the top updates"
      }

        ,
      {
        "id": "node-ovcxbvqcd", "parentId": "node-q23udh75a", "x": 960.9921875, "y": 370.09375, "color": "#FFFFFF", "text": "Copy and paste link to save"
      }

        ,
      {
        "id": "node-p4kqkvd10", "parentId": "node-q23udh75a", "x": 929.9921875, "y": 70.0859375, "color": "#FFFFFF", "text": "Encoded, but only against casual looking"
      }

        ,
      {
        "id": "node-11zyyd38b", "parentId": "node-q23udh75a", "x": 1060.984375, "y": 162.09375, "color": "#FF4500", "text": "Don't include confidential info"
      }

        ,
      {
        "id": "node-4y2pl7cq6", "parentId": "central-node", "x": 792, "y": 692.09375, "color": "#FFFFFF", "text": "Print to save a PDF"
      }

        ,
      {
        "id": "node-ajne4uz7j", "parentId": "central-node", "x": 467, "y": 697.09375, "color": "#FFFFFF", "text": "Can download JSON for later"
      }

        ,
      {
        "id": "node-6cwdh749f", "parentId": "central-node", "x": 852, "y": 525.09375, "color": "#FFFFFF", "text": "Export PNG for easy transfer to other apps"
      }

        ,
      {
        "id": "node-jes9tna46", "parentId": "central-node", "x": 844, "y": 612.09375, "color": "#FFFFFF", "text": "Export pptx for easy slides"
      }

      ];

      const serializedData = JSON.stringify(tutorialData);
      const encodedData = btoa(encodeURIComponent(serializedData));

      const url = new URL(window.location.href);
      url.hash = encodedData;
      window.open(url.toString(), '_blank');
    }

    function autoLayout() {
      pushToUndo();

      const containerRect = container.getBoundingClientRect();
      const centerX = containerRect.width / 2;
      const centerY = containerRect.height / 2;

      // Constants for layout
      const NODE_WIDTH = 140;
      const NODE_HEIGHT = 60;
      const H_GAP = 60;
      const V_GAP = 20;

      // 1. Build Tree Structure
      // We need a temporary tree structure to calculate dimensions
      const rootNodeData = nodesData.find(n => n.id === centralNodeId);
      if (!rootNodeData) return;

      function buildTree(nodeId) {
        const node = nodesData.find(n => n.id === nodeId);
        if (!node) return null;

        const layoutNode = {
          id: node.id,
          text: node.text,
          width: NODE_WIDTH,
          height: NODE_HEIGHT,
          x: 0,
          y: 0,
          children: [],
          side: null, // 'left' or 'right'
          treeHeight: 0
        };

        // Find children
        const childNodes = nodesData.filter(n => n.parentId === nodeId);
        layoutNode.children = childNodes.map(c => buildTree(c.id)).filter(n => n !== null);

        return layoutNode;
      }

      const root = buildTree(centralNodeId);
      if (!root) return;

      // Position root in center
      root.x = centerX - (root.width / 2);
      root.y = centerY - (root.height / 2);

      // 2. Assign Sides (Balance Left/Right for root children)
      // We alternate sides for immediate children of the root
      const rightChildren = [];
      const leftChildren = [];

      root.children.forEach((child, index) => {
        if (index % 2 === 0) {
          child.side = "right";
          rightChildren.push(child);
        } else {
          child.side = "left";
          leftChildren.push(child);
        }
      });

      // 3. Calculate Tree Heights (Pass 1: Bottom-Up)
      // This ensures we allocate enough vertical space for sub-trees
      function calculateTreeHeight(node) {
        if (!node.children || node.children.length === 0) {
          node.treeHeight = node.height;
          return node.height;
        }

        let h = 0;
        node.children.forEach(child => {
          h += calculateTreeHeight(child);
        });

        // Add gaps between children
        h += (node.children.length - 1) * V_GAP;

        // The node's treeHeight is the max of its own height and its children's total height
        // (Usually children stack is taller)
        node.treeHeight = Math.max(node.height, h);
        return node.treeHeight;
      }

      // Calculate heights for all root children
      root.children.forEach(calculateTreeHeight);


      // 4. Layout Children (Pass 2: Top-Down)
      function layoutChildren(parent) {
        // Separate children by side (only relevant for root, others inherit)
        // For non-root nodes, all children should be on the same side as the parent
        let pRightChildren, pLeftChildren;

        if (parent.id === centralNodeId) {
          pRightChildren = parent.children.filter(c => c.side === 'right');
          pLeftChildren = parent.children.filter(c => c.side === 'left');
        } else {
          // All children follow the parent's side
          if (parent.side === 'right') {
            pRightChildren = parent.children;
            pLeftChildren = [];
          } else {
            pRightChildren = [];
            pLeftChildren = parent.children;
          }
        }

        // Helper to place a stack of children
        const placeStack = (children, direction) => {
          if (children.length === 0) return;

          const totalHeight = children.reduce((sum, c) => sum + c.treeHeight, 0) + (children.length - 1) * V_GAP;

          // Start Y: Center the stack relative to the parent
          let currentY = parent.y + (parent.height / 2) - (totalHeight / 2);

          children.forEach(child => {
            // Inherit side
            child.side = direction;

            // Calculate child Y to center it in its allocated slot
            const childSlotHeight = child.treeHeight;
            const childY = currentY + (childSlotHeight - child.height) / 2;

            child.y = childY;

            if (direction === 'right') {
              child.x = parent.x + parent.width + H_GAP;
            } else {
              child.x = parent.x - child.width - H_GAP;
            }

            // Recursively layout this child's children
            layoutChildren(child);

            currentY += childSlotHeight + V_GAP;
          });
        };

        placeStack(pRightChildren, 'right');
        placeStack(pLeftChildren, 'left');
      }

      layoutChildren(root);

      // 5. Update nodesData and Render
      function updateNodesData(layoutNode) {
        const dataNode = nodesData.find(n => n.id === layoutNode.id);
        if (dataNode) {
          dataNode.x = layoutNode.x;
          dataNode.y = layoutNode.y;
        }
        layoutNode.children.forEach(updateNodesData);
      }

      updateNodesData(root);
      renderMindMap();
    }

    exportPngBtn.addEventListener('click', function () {
      document.body.classList.add('exporting');

      // 1. Calculate Bounds
      const bounds = getMindMapBounds();
      const padding = 100;
      const width = bounds.maxX - bounds.minX + (padding * 2);
      const height = bounds.maxY - bounds.minY + (padding * 2);

      // Warn if dimensions are potentially unsafe for canvas
      if (width > 16000 || height > 16000) {
        if (!confirm('This mind map is very large and might fail to export. Try creating it anyway?')) {
          document.body.classList.remove('exporting');
          return;
        }
      }

      // 2. Create Temporary Container
      const exportContainer = document.createElement('div');
      exportContainer.style.position = 'absolute'; // Changed from fixed to absolute to avoid viewport issues
      exportContainer.style.top = '0';
      exportContainer.style.left = '0';
      // Use Z-index to hide behind main content instead of translating off-screen
      // Translating off-screen prevents the browser from painting, resulting in blank images
      exportContainer.style.zIndex = '-9999';
      exportContainer.style.width = width + 'px';
      exportContainer.style.height = height + 'px';
      exportContainer.style.backgroundColor = 'white';
      // Ensure visibility is 'visible' for capture, but hidden by z-index
      exportContainer.style.visibility = 'visible';

      document.body.appendChild(exportContainer);

      // We need to shift everything by (-minX + padding, -minY + padding)
      const offsetX = -bounds.minX + padding;
      const offsetY = -bounds.minY + padding;

      // 3. Create SVG for lines
      const exportSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      exportSvg.setAttribute('width', width);
      exportSvg.setAttribute('height', height);
      exportSvg.style.position = 'absolute';
      exportSvg.style.top = '0';
      exportSvg.style.left = '0';
      exportSvg.style.pointerEvents = 'none';
      exportContainer.appendChild(exportSvg);

      // Draw lines
      nodesData.forEach(node => {
        if (node.parentId) {
          const parent = nodesData.find(n => n.id === node.parentId);
          if (parent) {
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            // Use same offset logic as original drawLine (+50, +30)
            line.setAttribute('x1', parent.x + 50 + offsetX);
            line.setAttribute('y1', parent.y + 30 + offsetY);
            line.setAttribute('x2', node.x + 50 + offsetX);
            line.setAttribute('y2', node.y + 30 + offsetY);
            line.setAttribute('stroke', 'rgba(0, 0, 0, 0.4)');
            line.setAttribute('stroke-width', '2');
            exportSvg.appendChild(line);
          }
        }
      });

      // 4. Render Nodes
      nodesData.forEach(node => {
        const nodeEl = document.createElement('div');
        nodeEl.className = 'node';
        if (node.id === 'central-node') nodeEl.classList.add('central-node');

        nodeEl.style.position = 'absolute';
        nodeEl.style.left = (node.x + offsetX) + 'px';
        nodeEl.style.top = (node.y + offsetY) + 'px';
        nodeEl.style.backgroundColor = node.color;

        // Remove transitions for static capture
        nodeEl.style.transition = 'none';
        nodeEl.style.boxShadow = 'none'; // Optional: remove shadow for cleaner print? Or keep.
        // Let's keep shadow for look, but ensure border is standard.
        nodeEl.style.border = '1px solid rgba(0,0,0,0.1)';

        // Reuse our helper to render inner content (text, images, links)
        // Pass 'false' for editMode
        renderNodeContent(nodeEl, node, false);

        exportContainer.appendChild(nodeEl);
      });

      // 5. Capture with html2canvas (with delay)
      // Small delay to allow the DOM to render/paint the new elements
      requestAnimationFrame(() => {
        setTimeout(() => {
          html2canvas(exportContainer, {
            scale: 2,
            backgroundColor: '#ffffff',
            width: width,
            height: height,
            logging: false
          }).then(canvas => {
            const imgData = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            const centralNodeText = nodesData.find(n => n.id === centralNodeId)?.text || 'MindMap';
            const fileName = `${centralNodeText.replace(/\s+/g, '_') || 'MindMap'}.png`;
            link.href = imgData;
            link.download = fileName;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          }).catch(err => {
            console.error('PNG export error:', err);
            alert('Error creating PNG. Please try again.');
          }).finally(() => {
            document.body.removeChild(exportContainer);
            document.body.classList.remove('exporting');
          });
        }, 100); // 100ms delay
      });
    });

    function getMindMapBounds() {
      let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

      if (nodesData.length === 0) return { minX: 0, maxX: 0, minY: 0, maxY: 0 };

      // Consider all nodes
      nodesData.forEach(node => {
        // Get rough dimensions - visual element would be better but data is safer/faster
        // Assuming ~150px width and ~60px height for safety if not measured
        const el = document.getElementById(node.id);
        const w = el ? el.offsetWidth : 150;
        const h = el ? el.offsetHeight : 60;

        minX = Math.min(minX, node.x);
        maxX = Math.max(maxX, node.x + w);
        minY = Math.min(minY, node.y);
        maxY = Math.max(maxY, node.y + h);
      });

      return { minX, maxX, minY, maxY };
    }

    // Download JSON with proper Unicode/emoji support
    function downloadJSON() {
      const centralNodeText = nodesData.find(n => n.id === centralNodeId)?.text || 'MindMap';
      const fileName = `${centralNodeText.replace(/\s+/g, '_') || 'MindMap'}.json`;

      // Encode the JSON data using TextEncoder for full Unicode/emoji support
      const serializedData = JSON.stringify(nodesData);
      const encoder = new TextEncoder();
      const encodedData = encoder.encode(serializedData);

      const blob = new Blob([encodedData], {
        type: 'application/json'
      });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }


    // Upload JSON with proper Unicode/emoji support and warning
    const uploadInput = document.getElementById('upload-json');
    let pendingFile = null;

    uploadInput.addEventListener('change', function (event) {
      const file = event.target.files[0];
      if (!file) return;

      // Clear the input value so the same file can be selected again
      uploadInput.value = '';

      // Check if current map is effectively empty (just central node with default text or empty)
      const isClean = nodesData.length === 1 && nodesData[0].id === centralNodeId && (!nodesData[0].text || nodesData[0].text === 'Central topic');

      if (isClean) {
        // If clean, just load it
        loadFile(file);
      }

      else {
        // Show warning modal
        pendingFile = file;
        document.getElementById('modal-overlay').style.display = 'flex';
      }
    });

    // Modal Actions
    document.getElementById('modal-cancel').addEventListener('click', () => {
      closeModal();
      pendingFile = null;
    });

    document.getElementById('modal-overwrite').addEventListener('click', () => {
      if (pendingFile) {
        loadFile(pendingFile);
      }

      closeModal();
    });

    document.getElementById('modal-new-window').addEventListener('click', () => {
      if (pendingFile) {
        openInNewWindow(pendingFile);
      }

      closeModal();
    });

    function closeModal() {
      document.getElementById('modal-overlay').style.display = 'none';
    }

    function loadFile(file) {
      const reader = new FileReader();

      reader.onload = function (e) {
        try {
          const decodedData = e.target.result;
          const parsedData = JSON.parse(decodedData);
          nodesData = parsedData;
          renderMindMap();
        }

        catch (error) {
          console.error('Failed to load mind map:', error);
          alert('Invalid mind map file.');
        }
      }

        ;
      reader.readAsText(file);
    }

    function openInNewWindow(file) {
      const reader = new FileReader();

      reader.onload = function (e) {
        try {
          const decodedData = e.target.result;
          // Validate JSON first
          JSON.parse(decodedData);

          // Create URL with hash
          const encodedData = btoa(encodeURIComponent(decodedData));
          const currentUrl = window.location.href.split('#')[0];
          const newUrl = currentUrl + '#' + encodedData;

          window.open(newUrl, '_blank');
        }

        catch (error) {
          console.error('Failed to open in new window:', error);
          alert('Invalid mind map file.');
        }
      }

        ;
      reader.readAsText(file);
    }





    // Event listener for color palette
    colorPalette.addEventListener('click', (event) => {
      if (event.target.classList.contains('color-swatch')) {
        const color = event.target.getAttribute('data-color');
        changeNodeColor(color);
      }
    });

    // Event listeners for emoji buttons
    emojiButtons.forEach(button => {
      button.addEventListener('click', () => {
        const emoji = button.getAttribute('data-emoji');
        addEmojiToSelectedNode(emoji);
      });
    });

    function addEmojiToSelectedNode(emoji) {
      if (!selectedNodeId) {
        alert('No node selected.');
        return;
      }

      const node = nodesData.find(n => n.id === selectedNodeId);

      if (node) {
        pushToUndo();
        const emojis = ['üí°',
          'üß†',
          'üìö',
          'üéØ',
          '‚úÖ',
          '‚ùå',
          'üõ†Ô∏è',
          'üö¶',
          'üé¨'];
        let currentText = node.text.trim();

        const existingEmoji = emojis.find(e => currentText.startsWith(e));

        if (existingEmoji) {
          node.text = currentText.replace(existingEmoji, emoji);
        }

        else {
          node.text = (currentText ? emoji + ' ' + currentText : emoji);
        }

        renderMindMap();
      }
    }

    function loadFromURL() {
      if (window.location.hash.length > 1) {
        try {
          const rawHash = window.location.hash.substring(1);

          // Attempt to decode URI component (handles % characters)
          let encodedData = rawHash;
          try {
            encodedData = decodeURIComponent(rawHash);
          } catch (e) {
            console.warn('Outer decode failed, using raw hash', e);
          }

          const decodedBase64 = atob(encodedData);
          const decodedData = decodeURIComponent(decodedBase64);
          const parsedData = JSON.parse(decodedData);

          console.log('Loading from URL, parsed data:', parsedData);

          // Simply use the parsed data directly
          nodesData = parsedData;

          console.log('nodesData after loading:', nodesData);

          // Center the nodes if needed
          const centralNodeData = nodesData.find(n => n.id === centralNodeId || n.parentId === null);
          if (centralNodeData && (centralNodeData.x === 0 || centralNodeData.y === 0)) {
            centerNodePosition(centralNodeData.id);
          }

          isInitialized = true;
          renderMindMap();
        } catch (error) {
          console.error('Failed to load mind map from URL:', error);
          // Initialize with default if loading fails
          nodesData = [{
            id: centralNodeId,
            parentId: null,
            x: 0,
            y: 0,
            color: colors[0],
            text: ''
          }];
          centerNodePosition(centralNodeId);
          isInitialized = true;
          renderMindMap();
        }
      } else {

        // Initialize with default central node if empty
        if (nodesData.length === 0) {
          nodesData = [{
            id: centralNodeId,
            parentId: null,
            x: 0,
            y: 0,
            color: colors[0],
            text: ''
          }

          ];
        }

        centerNodePosition(centralNodeId);
        isInitialized = true;
        renderMindMap();
      }
    }

    function centerNodePosition(nodeId) {
      const node = nodesData.find(n => n.id === nodeId);

      if (node) {
        const containerRect = container.getBoundingClientRect();
        node.x = (containerRect.width / 2) - 50;
        node.y = (containerRect.height / 2) - 30;
      }
    }

    //Export PPTX
    document.getElementById('export-pptx-btn').addEventListener('click', function () {
      const pptx = new PptxGenJS();

      // Slide 1: Title Slide with Central Node Name
      // Find central node dynamically (node with no parent)
      const centralNode = nodesData.find(n => !n.parentId);
      const centralNodeText = centralNode?.text || 'Mind Map';

      const titleSlide = pptx.addSlide({
        masterName: 'TITLE_SLIDE'
      });

      // Expand the title text box for the first slide
      titleSlide.addText(centralNodeText, {
        x: 0.5,
        y: 2,
        w: 9, // Expanding the width of the title text box
        h: 1, // Expanding the height of the title text box
        fontSize: 36,
        bold: true,
        align: 'center'
      });

      // Slide 2: Mind Map Image
      const slide2 = pptx.addSlide();

      // Hide toolbar for the export
      document.body.classList.add('exporting');

      // Calculate bounds for PPTX export too
      const bounds = getMindMapBounds();
      const padding = 50;
      const width = bounds.maxX - bounds.minX + (padding * 2);
      const height = bounds.maxY - bounds.minY + (padding * 2);
      const originalTransform = canvasLayer.style.transform;

      // Shift to show all content
      canvasLayer.style.transform = `translate3d(${-bounds.minX + padding}px, ${-bounds.minY + padding}px, 0)`;

      html2canvas(document.querySelector('#mindmap-container'), {
        scale: 2,
        backgroundColor: null,
        useCORS: true,
        width: width,
        height: height,
        windowWidth: width,
        windowHeight: height,
        scrollX: 0,
        scrollY: 0
      }).then(canvas => {
        const imgData = canvas.toDataURL('image/png');

        slide2.addImage({
          data: imgData, x: 0, y: 0, w: 10, h: 5.625
        });

        // Slide 3: Single Text Box with Proper Bulleted List (Flat, no indentation)
        const slide3 = pptx.addSlide();

        // Title for the slide
        slide3.addText(centralNodeText, {
          x: 0.5,
          y: 0.1,
          w: 9, // Make the text box wide enough
          h: 1, // Adjust the height as needed for the title
          fontSize: 24,
          bold: true
        });

        // Create an array of text objects for rich text support (links)
        const textItems = nodesData
          .filter(n => n.id !== centralNodeId)
          .map(node => ({
            text: node.text || 'Node',
            options: {
              breakLine: true,
              hyperlink: node.link ? { url: node.link } : undefined,
              color: node.link ? '0563C1' : undefined // Standard link blue
            }
          }));

        // Add the text items as a bulleted list
        slide3.addText(textItems, {
          x: 0.5,  // X position for the text box
          y: 1,    // Y position for the bullets
          w: 9,    // Width of the text box
          h: 4.5,  // Height of the text box
          fontSize: 18,
          align: 'left',
          bullet: true  // Enable PowerPoint's bullet functionality
        });


        // Name the file based on the central node's text
        const fileName = `${centralNodeText.replace(/\s+/g, '_') || 'MindMap'}.pptx`;

        // Save the PowerPoint
        pptx.writeFile({
          fileName: fileName
        });

      }).finally(() => {
        canvasLayer.style.transform = originalTransform;
        document.body.classList.remove('exporting');
      });
    });

    // Link/Image Modal Logic
    const linkModalOverlay = document.getElementById('link-modal-overlay');
    const linkUrlInput = document.getElementById('link-url-input');
    const linkModalSave = document.getElementById('link-modal-save');
    const linkModalRemove = document.getElementById('link-modal-remove');
    const linkModalCancel = document.getElementById('link-modal-cancel');
    const linkTypeRadios = document.getElementsByName('link-type');
    const imageSizeContainer = document.getElementById('image-size-container');
    const imageSizeSlider = document.getElementById('image-size-slider');
    const imageSizeValue = document.getElementById('image-size-value');
    const imageFileInput = document.getElementById('image-file-input');
    const imageUploadContainer = document.getElementById('image-upload-container');

    // Helper to convert image source to resized Data URI
    async function processImageToDataURL(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "Anonymous"; // Try to request CORS
        img.onload = () => {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          // Resize logic (max 300px)
          const maxDim = 300;
          let w = img.width;
          let h = img.height;
          if (w > maxDim || h > maxDim) {
            const ratio = Math.min(maxDim / w, maxDim / h);
            w *= ratio;
            h *= ratio;
          }
          canvas.width = w;
          canvas.height = h;
          ctx.drawImage(img, 0, 0, w, h);
          resolve(canvas.toDataURL('image/jpeg', 0.8)); // Compress
        };
        img.onerror = (e) => reject(e);
        img.src = src;
      });
    }

    // Update slider value display
    imageSizeSlider.addEventListener('input', () => {
      imageSizeValue.textContent = imageSizeSlider.value;
    });

    // Toggle slider visibility based on type
    function updateSliderVisibility() {
      const type = getLinkType();
      imageSizeContainer.style.display = type === 'image' ? 'block' : 'none';
      imageUploadContainer.style.display = type === 'image' ? 'block' : 'none';

      // Adjust URL input placeholder based on type
      const linkUrlInput = document.getElementById('link-url-input');
      if (type === 'image') {
        linkUrlInput.placeholder = "Enter Image URL (or upload below)";
      } else {
        linkUrlInput.placeholder = "Enter URL (https://...)";
      }
    }

    // Add listeners to radios
    linkTypeRadios.forEach(radio => {
      radio.addEventListener('change', updateSliderVisibility);
    });

    function addLink() {
      if (!selectedNodeId) {
        alert('Please select a node first.');
        return;
      }
      const node = nodesData.find(n => n.id === selectedNodeId);
      if (!node) return;

      // Pre-fill modal
      if (node.image) {
        linkUrlInput.value = node.image;
        setLinkType('image');
        // Set slider
        if (node.imageSize) {
          imageSizeSlider.value = node.imageSize;
          imageSizeValue.textContent = node.imageSize;
        } else {
          imageSizeSlider.value = 150;
          imageSizeValue.textContent = 150;
        }
      } else if (node.link) {
        linkUrlInput.value = node.link;
        setLinkType('link');
      } else {
        linkUrlInput.value = '';
        setLinkType('link'); // Default
        imageSizeSlider.value = 150;
        imageSizeValue.textContent = 150;
      }

      // Reset file input
      imageFileInput.value = '';

      updateSliderVisibility();

      linkModalOverlay.style.display = 'flex';
      linkUrlInput.focus();
    }

    function setLinkType(type) {
      for (const radio of linkTypeRadios) {
        if (radio.value === type) {
          radio.checked = true;
        }
      }
    }

    function getLinkType() {
      for (const radio of linkTypeRadios) {
        if (radio.checked) return radio.value;
      }
      return 'link';
    }

    function closeLinkModal() {
      linkModalOverlay.style.display = 'none';
    }

    linkModalCancel.addEventListener('click', closeLinkModal);

    linkModalRemove.addEventListener('click', () => {
      const node = nodesData.find(n => n.id === selectedNodeId);
      if (node) {
        pushToUndo();
        delete node.link;
        delete node.image;
        delete node.imageSize;
        renderMindMap();
      }
      closeLinkModal();
    });

    linkModalSave.addEventListener('click', async () => {
      const node = nodesData.find(n => n.id === selectedNodeId);
      if (node) {
        const url = linkUrlInput.value.trim();
        const type = getLinkType();

        if (url || (imageFileInput.files && imageFileInput.files[0])) {
          pushToUndo();
          // Clear both first to ensure we switch types cleanly
          delete node.link;
          delete node.image;
          delete node.imageSize;

          if (type === 'image') {
            // Check if file was uploaded
            if (imageFileInput.files && imageFileInput.files[0]) {
              console.log('File selected:', imageFileInput.files[0].name);
              const file = imageFileInput.files[0];
              const reader = new FileReader();
              reader.onload = async (e) => {
                console.log('File read, size:', e.target.result.length);
                try {
                  const dataUrl = await processImageToDataURL(e.target.result);
                  console.log('Data URL created, length:', dataUrl.length);
                  node.image = dataUrl;
                  finishSave();
                } catch (err) {
                  console.error("Failed to process uploaded image", err);
                  alert("Failed to process image: " + err.message);
                  finishSave(); // Still close modal even if image processing fails
                }
              };
              reader.readAsDataURL(file);
              return; // Wait for reader
            }
            // Else try to process URL
            else if (url) {
              try {
                const dataUrl = await processImageToDataURL(url);
                node.image = dataUrl;
              } catch (err) {
                console.warn("CORS blocked image processing, using raw URL", err);
                node.image = url;
              }
              finishSave();
            } else {
              // No image provided
              finishSave();
            }
          } else {
            // Simple protocol check for links
            let finalUrl = url;
            if (finalUrl && !/^https?:\/\//i.test(finalUrl) && !/^mailto:/i.test(finalUrl)) {
              finalUrl = 'https://' + finalUrl;
            }
            node.link = finalUrl;
            finishSave();
          }

          function finishSave() {
            if (type === 'image') {
              const size = parseInt(imageSizeSlider.value, 10);
              if (size) {
                node.imageSize = size;
              }
            }
            renderMindMap();
            closeLinkModal();
          }
        } else { // If no URL and no file, just close the modal
          closeLinkModal();
        }
      } else {
        closeLinkModal();
      }
    });

  </script>
  <!-- 100% privacy-first analytics -->
  <script async defer src="https://scripts.simpleanalyticscdn.com/latest.js"></script><noscript><img
      src="https://queue.simpleanalyticscdn.com/noscript.gif" alt=""
      referrerpolicy="no-referrer-when-downgrade" /></noscript>
</body>

</html>
